modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype OurScenarios uses MDAScenarios('mdaScenarios.de.uni-augsburg');

transformation Import(in input : UML, out output : OurScenarios);

main(){
	var content := object OurScenarios::Content
	{
		name:=input.objectsOfType(UML::Model).name->any(true);
	};
	content.states := input.objectsOfType(UML::StateInvariant)->copyStateInvariant();
	log("Copied States");
	log(input.objectsOfType(UML::Message).signature->size().toString());
	content.operations += input.objectsOfType(UML::Message).signature->oclAsType(UML::NamedElement).map transformMessage();
	log("Tranfsormed Messages");
	
	content.participants += input.objectsOfType(UML::Lifeline).represents.type.map transformParticipant();
	log("Tranfsormed Participants");
	
	content.scenarios += input.objectsOfType(UML::Interaction).map transformScenario(content);
	log("Transformed Scenarios");

	log("Done");
}

helper Collection(StateInvariant)::copyStateInvariant():OrderedSet(OurScenarios::State){
	var retList := object OrderedSet(OurScenarios::State){
		
	};
	self->forEach(element){
		if (retList->select ( state | state.name = element.invariant.name)->isEmpty()){
			retList += object OurScenarios::State{
				name := element.invariant.name;
			}
		}endif;
	};
	log("reduced to "+ retList->size().toString() +" states");
	return retList;
}

mapping NamedElement::transformMessage():OurScenarios::Operation
	disjuncts Operation::transformMessage,
			Signal::transformMessage;

mapping UML::Operation::transformMessage():OurScenarios::Operation{
	log("Mapped Operation:"+ self.name);
	name:=self.name;
}

mapping UML::Signal::transformMessage():OurScenarios::Operation{
	log("Mapped Signal:" +self.name);
	name:=self.name;
}

mapping Type::transformParticipant():OurScenarios::Participant{
	name:=self.name;
}

mapping Interaction::transformScenario(in c: OurScenarios::Content):OurScenarios::ScenarioTable{
	name:=self.name;
	records += self.fragment.map transformFragment(c);
}

mapping InteractionFragment::transformFragment(in c : OurScenarios::Content):OurScenarios::ScenarioRecord
	disjuncts MessageOccurrenceSpecification::transformFragment;
	
mapping MessageOccurrenceSpecification::transformFragment(in c : OurScenarios::Content):OurScenarios::ScenarioRecord
	when {
	//Precondition. We only need to take this OccuranceSpec if it is a ReceiveEvent!
		self.message.receiveEvent = self and self.message.messageSort = MessageSort::synchCall;
	}{
		//we have one receiveEvent here. First get the sender and receiver
		receiver := self.oclAsType(OccurrenceSpecification).covered.represents.type.resolveone(OurScenarios::Participant);//c.participants->select(p | p.name = self.covered.represents->any(true).type.name)->first();
		sender := self.message.sendEvent.oclAsType(OccurrenceSpecification).covered.represents.type.resolveone(OurScenarios::Participant);//c.participants->select(p | p.name = self.message.sendEvent.oclAsType(UML::MessageOccurrenceSpecification).covered.represents->any(true).type.name)->first();
		operation := self.message.signature.resolveone(OurScenarios::Operation);//c.operations->select(o | o.name = self.message.signature.name)->first();
		log("Searching returnValue for Op: " + operation.name.toString() + " invoker: " + sender.name.toString());
		returnValue := object OurScenarios::Value{
			value := self.getReturnValue(sender);
		};
		
		//It gives us a set. hopefully in the right order :/
		var fragmentList := input.objectsOfType(UML::InteractionFragment);
		var before = true;
		var thePreState := "";
		var thePostState := "";
		fragmentList->forEach(element){
			//We go through every interactionfragment and buffer the prestate until we found the self element
			//The next state is the postState
			if (element.oclIsTypeOf(UML::StateInvariant)){
				var elementState := element.oclAsType(UML::StateInvariant);
				//It must be our Lifeline!
				if (elementState.covered = self.covered){
					if (before){
						thePreState := element.oclAsType(UML::StateInvariant).invariant.name;
					}else{
						thePostState := element.oclAsType(UML::StateInvariant).invariant.name;
						break;
					}
				}
			}else if (element.oclIsTypeOf(UML::MessageOccurrenceSpecification)){
				if (element = self){
					before := false;
				}
			};
		};
		//TODO This that is in here has to be written back to the usual Content
		log(thePreState + " | " + self.message.signature.name +" | " + thePostState);
}

helper MessageOccurrenceSpecification::getReturnValue(in invoker:Participant):String{
	var foundSelf := false;
	var lifeline := self.covered->any(true);
	lifeline.interaction.fragment->forEach(fragment){
		if(fragment.oclIsTypeOf(MessageOccurrenceSpecification) and fragment.covered->exists(l|l=lifeline)){
			if(fragment = self){
				foundSelf := true;
				log("found self");
			}
			else if(foundSelf and fragment.oclAsType(MessageOccurrenceSpecification).isSendingToParticipant(invoker)){
				var message := fragment.oclAsType(MessageOccurrenceSpecification).message;
				log("nextMsg: " + message.signature.name.toString() + " sort: " +message.messageSort.toString());
				if(message.messageSort = MessageSort::reply){
					return message.name;
				}else {
					return "Void";
				}endif;
			}endif;
		}endif;
	};
	return "Void";
}

helper MessageOccurrenceSpecification::isSendingToParticipant(in participant:Participant):Boolean{
	log(self.message.receiveEvent.oclAsType(MessageOccurrenceSpecification).covered->any(true).represents.type.name);
	return self.message.receiveEvent.oclAsType(MessageOccurrenceSpecification).covered->any(true).represents.type.resolveone(Participant) = participant;
}

//todelete
helper Interaction::getNextSendMsgOccSpec(in lifeline:Lifeline,in mos:MessageOccurrenceSpecification):MessageOccurrenceSpecification{
	var foundMOS = false;
	self.fragment->forEach(fragment){
		if(fragment.oclIsTypeOf(MessageOccurrenceSpecification) and fragment.covered->exists(l|l=lifeline)) {
			if(fragment.oclAsType(MessageOccurrenceSpecification)=mos and not foundMOS){
				foundMOS := true;
			}endif;
			if(foundMOS and fragment.oclAsType(MessageOccurrenceSpecification).isSendMsgOccSpec()){
				return fragment.oclAsType(MessageOccurrenceSpecification);
			}
		}endif;
	};
	return null;
}

helper MessageOccurrenceSpecification::isSendMsgOccSpec():Boolean{
	return self.message.sendEvent=self;
}

//Deprecated and not used...
helper Set(InteractionFragment)::getObectByIndex(in index: Integer):InteractionFragment{
	var act := 0;
	self->forEach(element){
		if (act=index){
			return element;
		}endif;
		act := act +1;
	};
	return null;
}


//Also deprecated!
//This method just builds up a dictionary of Index and States for defined Lifelines
//each participant has one Dictionary. This means, it fills up a 2D-Dict
//Lifeline -> GlobalIndex -> State
helper StateInvariant::buildStateDict(){
	//If build. Iterate through the keys per lifeline and search after the biggest a smaller b and the smallest c greater b
	//b is the MessageOccurance. a < b < c is then the optimum for a = preState and b = postState
	//Maybe not needed...
}
